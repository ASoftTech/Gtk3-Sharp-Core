// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Style : GLib.Object {

		public Style (IntPtr raw) : base(raw) {}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_style_new();

		public Style () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Style)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = gtk_style_new();
		}

		[GLib.Property ("context")]
		public Gtk.StyleContext Context {
			get {
				GLib.Value val = GetProperty ("context");
				Gtk.StyleContext ret = (Gtk.StyleContext) val;
				val.Dispose ();
				return ret;
			}
		}

		[DllImport ("gtksharpglue-3")]
		extern static uint gtksharp_gtk_style_get_black_offset ();

		static uint black_offset = gtksharp_gtk_style_get_black_offset ();
		public Gdk.Color Black {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + black_offset);
					return Gdk.Color.New ((*raw_ptr));
				}
			}
		}

		[DllImport ("gtksharpglue-3")]
		extern static uint gtksharp_gtk_style_get_white_offset ();

		static uint white_offset = gtksharp_gtk_style_get_white_offset ();
		public Gdk.Color White {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + white_offset);
					return Gdk.Color.New ((*raw_ptr));
				}
			}
		}

		[DllImport ("gtksharpglue-3")]
		extern static uint gtksharp_gtk_style_get_font_desc_offset ();

		static uint font_desc_offset = gtksharp_gtk_style_get_font_desc_offset ();
		public Pango.FontDescription FontDesc {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + font_desc_offset);
					return (*raw_ptr) == IntPtr.Zero ? null : (Pango.FontDescription) GLib.Opaque.GetOpaque ((*raw_ptr), typeof (Pango.FontDescription), false);
				}
			}
		}

		[DllImport ("gtksharpglue-3")]
		extern static uint gtksharp_gtk_style_get_xthickness_offset ();

		static uint xthickness_offset = gtksharp_gtk_style_get_xthickness_offset ();
		public int Xthickness {
			get {
				unsafe {
					int* raw_ptr = (int*)(((byte*)Handle) + xthickness_offset);
					return (*raw_ptr);
				}
			}
		}

		[DllImport ("gtksharpglue-3")]
		extern static uint gtksharp_gtk_style_get_ythickness_offset ();

		static uint ythickness_offset = gtksharp_gtk_style_get_ythickness_offset ();
		public int Ythickness {
			get {
				unsafe {
					int* raw_ptr = (int*)(((byte*)Handle) + ythickness_offset);
					return (*raw_ptr);
				}
			}
		}

		[GLib.Signal("realize")]
		public event System.EventHandler Realize {
			add {
				this.AddSignalHandler ("realize", value);
			}
			remove {
				this.RemoveSignalHandler ("realize", value);
			}
		}

		[GLib.Signal("unrealize")]
		public event System.EventHandler Unrealize {
			add {
				this.AddSignalHandler ("unrealize", value);
			}
			remove {
				this.RemoveSignalHandler ("unrealize", value);
			}
		}

		static RealizeNativeDelegate Realize_cb_delegate;
		static RealizeNativeDelegate RealizeVMCallback {
			get {
				if (Realize_cb_delegate == null)
					Realize_cb_delegate = new RealizeNativeDelegate (Realize_cb);
				return Realize_cb_delegate;
			}
		}

		static void OverrideRealize (GLib.GType gtype)
		{
			OverrideRealize (gtype, RealizeVMCallback);
		}

		static void OverrideRealize (GLib.GType gtype, RealizeNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.Realize = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void RealizeNativeDelegate (IntPtr inst);

		static void Realize_cb (IntPtr inst)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				__obj.OnRealize ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideRealize")]
		protected virtual void OnRealize ()
		{
			InternalRealize ();
		}

		private void InternalRealize ()
		{
			RealizeNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Realize;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static UnrealizeNativeDelegate Unrealize_cb_delegate;
		static UnrealizeNativeDelegate UnrealizeVMCallback {
			get {
				if (Unrealize_cb_delegate == null)
					Unrealize_cb_delegate = new UnrealizeNativeDelegate (Unrealize_cb);
				return Unrealize_cb_delegate;
			}
		}

		static void OverrideUnrealize (GLib.GType gtype)
		{
			OverrideUnrealize (gtype, UnrealizeVMCallback);
		}

		static void OverrideUnrealize (GLib.GType gtype, UnrealizeNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.Unrealize = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnrealizeNativeDelegate (IntPtr inst);

		static void Unrealize_cb (IntPtr inst)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				__obj.OnUnrealize ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideUnrealize")]
		protected virtual void OnUnrealize ()
		{
			InternalUnrealize ();
		}

		private void InternalUnrealize ()
		{
			UnrealizeNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Unrealize;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static CopyNativeDelegate Copy_cb_delegate;
		static CopyNativeDelegate CopyVMCallback {
			get {
				if (Copy_cb_delegate == null)
					Copy_cb_delegate = new CopyNativeDelegate (Copy_cb);
				return Copy_cb_delegate;
			}
		}

		static void OverrideCopy (GLib.GType gtype)
		{
			OverrideCopy (gtype, CopyVMCallback);
		}

		static void OverrideCopy (GLib.GType gtype, CopyNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.Copy = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CopyNativeDelegate (IntPtr inst, IntPtr src);

		static void Copy_cb (IntPtr inst, IntPtr src)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				__obj.OnCopy (GLib.Object.GetObject(src) as Gtk.Style);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideCopy")]
		protected virtual void OnCopy (Gtk.Style src)
		{
			InternalCopy (src);
		}

		private void InternalCopy (Gtk.Style src)
		{
			CopyNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Copy;
			if (unmanaged == null) return;

			unmanaged (this.Handle, src == null ? IntPtr.Zero : src.Handle);
		}

		static CloneNativeDelegate Clone_cb_delegate;
		static CloneNativeDelegate CloneVMCallback {
			get {
				if (Clone_cb_delegate == null)
					Clone_cb_delegate = new CloneNativeDelegate (Clone_cb);
				return Clone_cb_delegate;
			}
		}

		static void OverrideClone (GLib.GType gtype)
		{
			OverrideClone (gtype, CloneVMCallback);
		}

		static void OverrideClone (GLib.GType gtype, CloneNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.Clone = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CloneNativeDelegate (IntPtr inst);

		static IntPtr Clone_cb (IntPtr inst)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				Gtk.Style __result;
				__result = __obj.OnClone ();
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideClone")]
		protected virtual Gtk.Style OnClone ()
		{
			return InternalClone ();
		}

		private Gtk.Style InternalClone ()
		{
			CloneNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Clone;
			if (unmanaged == null) return null;

			IntPtr __result = unmanaged (this.Handle);
			return GLib.Object.GetObject(__result) as Gtk.Style;
		}

		static InitFromRcNativeDelegate InitFromRc_cb_delegate;
		static InitFromRcNativeDelegate InitFromRcVMCallback {
			get {
				if (InitFromRc_cb_delegate == null)
					InitFromRc_cb_delegate = new InitFromRcNativeDelegate (InitFromRc_cb);
				return InitFromRc_cb_delegate;
			}
		}

		static void OverrideInitFromRc (GLib.GType gtype)
		{
			OverrideInitFromRc (gtype, InitFromRcVMCallback);
		}

		static void OverrideInitFromRc (GLib.GType gtype, InitFromRcNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.InitFromRc = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void InitFromRcNativeDelegate (IntPtr inst, IntPtr rc_style);

		static void InitFromRc_cb (IntPtr inst, IntPtr rc_style)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				__obj.OnInitFromRc (GLib.Object.GetObject(rc_style) as Gtk.RcStyle);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideInitFromRc")]
		protected virtual void OnInitFromRc (Gtk.RcStyle rc_style)
		{
			InternalInitFromRc (rc_style);
		}

		private void InternalInitFromRc (Gtk.RcStyle rc_style)
		{
			InitFromRcNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).InitFromRc;
			if (unmanaged == null) return;

			unmanaged (this.Handle, rc_style == null ? IntPtr.Zero : rc_style.Handle);
		}

		static SetBackgroundNativeDelegate SetBackground_cb_delegate;
		static SetBackgroundNativeDelegate SetBackgroundVMCallback {
			get {
				if (SetBackground_cb_delegate == null)
					SetBackground_cb_delegate = new SetBackgroundNativeDelegate (SetBackground_cb);
				return SetBackground_cb_delegate;
			}
		}

		static void OverrideSetBackground (GLib.GType gtype)
		{
			OverrideSetBackground (gtype, SetBackgroundVMCallback);
		}

		static void OverrideSetBackground (GLib.GType gtype, SetBackgroundNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.SetBackground = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetBackgroundNativeDelegate (IntPtr inst, IntPtr window, int state_type);

		static void SetBackground_cb (IntPtr inst, IntPtr window, int state_type)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				__obj.OnSetBackground (GLib.Object.GetObject(window) as Gdk.Window, (Gtk.StateType) state_type);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideSetBackground")]
		protected virtual void OnSetBackground (Gdk.Window window, Gtk.StateType state_type)
		{
			InternalSetBackground (window, state_type);
		}

		private void InternalSetBackground (Gdk.Window window, Gtk.StateType state_type)
		{
			SetBackgroundNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).SetBackground;
			if (unmanaged == null) return;

			unmanaged (this.Handle, window == null ? IntPtr.Zero : window.Handle, (int) state_type);
		}

		static RenderIconNativeDelegate RenderIcon_cb_delegate;
		static RenderIconNativeDelegate RenderIconVMCallback {
			get {
				if (RenderIcon_cb_delegate == null)
					RenderIcon_cb_delegate = new RenderIconNativeDelegate (RenderIcon_cb);
				return RenderIcon_cb_delegate;
			}
		}

		static void OverrideRenderIcon (GLib.GType gtype)
		{
			OverrideRenderIcon (gtype, RenderIconVMCallback);
		}

		static void OverrideRenderIcon (GLib.GType gtype, RenderIconNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.RenderIcon = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr RenderIconNativeDelegate (IntPtr inst, IntPtr source, int direction, int state, int size, IntPtr widget, IntPtr detail);

		static IntPtr RenderIcon_cb (IntPtr inst, IntPtr source, int direction, int state, int size, IntPtr widget, IntPtr detail)
		{
			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				Gdk.Pixbuf __result;
				__result = __obj.OnRenderIcon (source == IntPtr.Zero ? null : (Gtk.IconSource) GLib.Opaque.GetOpaque (source, typeof (Gtk.IconSource), false), (Gtk.TextDirection) direction, (Gtk.StateType) state, (Gtk.IconSize) size, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideRenderIcon")]
		protected virtual Gdk.Pixbuf OnRenderIcon (Gtk.IconSource source, Gtk.TextDirection direction, Gtk.StateType state, Gtk.IconSize size, Gtk.Widget widget, string detail)
		{
			return InternalRenderIcon (source, direction, state, size, widget, detail);
		}

		private Gdk.Pixbuf InternalRenderIcon (Gtk.IconSource source, Gtk.TextDirection direction, Gtk.StateType state, Gtk.IconSize size, Gtk.Widget widget, string detail)
		{
			RenderIconNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).RenderIcon;
			if (unmanaged == null) return null;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			IntPtr __result = unmanaged (this.Handle, source == null ? IntPtr.Zero : source.Handle, (int) direction, (int) state, (int) size, widget == null ? IntPtr.Zero : widget.Handle, native_detail);
			GLib.Marshaller.Free (native_detail);
			return GLib.Object.GetObject(__result) as Gdk.Pixbuf;
		}

		static DrawHlineNativeDelegate DrawHline_cb_delegate;
		static DrawHlineNativeDelegate DrawHlineVMCallback {
			get {
				if (DrawHline_cb_delegate == null)
					DrawHline_cb_delegate = new DrawHlineNativeDelegate (DrawHline_cb);
				return DrawHline_cb_delegate;
			}
		}

		static void OverrideDrawHline (GLib.GType gtype)
		{
			OverrideDrawHline (gtype, DrawHlineVMCallback);
		}

		static void OverrideDrawHline (GLib.GType gtype, DrawHlineNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawHline = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawHlineNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x1, int x2, int y);

		static void DrawHline_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x1, int x2, int y)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawHline (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x1, x2, y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawHline")]
		protected virtual void OnDrawHline (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x1, int x2, int y)
		{
			InternalDrawHline (cr, state_type, widget, detail, x1, x2, y);
		}

		private void InternalDrawHline (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x1, int x2, int y)
		{
			DrawHlineNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawHline;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x1, x2, y);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawVlineNativeDelegate DrawVline_cb_delegate;
		static DrawVlineNativeDelegate DrawVlineVMCallback {
			get {
				if (DrawVline_cb_delegate == null)
					DrawVline_cb_delegate = new DrawVlineNativeDelegate (DrawVline_cb);
				return DrawVline_cb_delegate;
			}
		}

		static void OverrideDrawVline (GLib.GType gtype)
		{
			OverrideDrawVline (gtype, DrawVlineVMCallback);
		}

		static void OverrideDrawVline (GLib.GType gtype, DrawVlineNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawVline = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawVlineNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int y1_, int y2_, int x);

		static void DrawVline_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int y1_, int y2_, int x)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawVline (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), y1_, y2_, x);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawVline")]
		protected virtual void OnDrawVline (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int y1_, int y2_, int x)
		{
			InternalDrawVline (cr, state_type, widget, detail, y1_, y2_, x);
		}

		private void InternalDrawVline (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int y1_, int y2_, int x)
		{
			DrawVlineNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawVline;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, y1_, y2_, x);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawShadowNativeDelegate DrawShadow_cb_delegate;
		static DrawShadowNativeDelegate DrawShadowVMCallback {
			get {
				if (DrawShadow_cb_delegate == null)
					DrawShadow_cb_delegate = new DrawShadowNativeDelegate (DrawShadow_cb);
				return DrawShadow_cb_delegate;
			}
		}

		static void OverrideDrawShadow (GLib.GType gtype)
		{
			OverrideDrawShadow (gtype, DrawShadowVMCallback);
		}

		static void OverrideDrawShadow (GLib.GType gtype, DrawShadowNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawShadow = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawShadowNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawShadow_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawShadow (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawShadow")]
		protected virtual void OnDrawShadow (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawShadow (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawShadow (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawShadowNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawShadow;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawArrowNativeDelegate DrawArrow_cb_delegate;
		static DrawArrowNativeDelegate DrawArrowVMCallback {
			get {
				if (DrawArrow_cb_delegate == null)
					DrawArrow_cb_delegate = new DrawArrowNativeDelegate (DrawArrow_cb);
				return DrawArrow_cb_delegate;
			}
		}

		static void OverrideDrawArrow (GLib.GType gtype)
		{
			OverrideDrawArrow (gtype, DrawArrowVMCallback);
		}

		static void OverrideDrawArrow (GLib.GType gtype, DrawArrowNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawArrow = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawArrowNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int arrow_type, bool fill, int x, int y, int width, int height);

		static void DrawArrow_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int arrow_type, bool fill, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawArrow (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), (Gtk.ArrowType) arrow_type, fill, x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawArrow")]
		protected virtual void OnDrawArrow (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, Gtk.ArrowType arrow_type, bool fill, int x, int y, int width, int height)
		{
			InternalDrawArrow (cr, state_type, shadow_type, widget, detail, arrow_type, fill, x, y, width, height);
		}

		private void InternalDrawArrow (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, Gtk.ArrowType arrow_type, bool fill, int x, int y, int width, int height)
		{
			DrawArrowNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawArrow;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, (int) arrow_type, fill, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawDiamondNativeDelegate DrawDiamond_cb_delegate;
		static DrawDiamondNativeDelegate DrawDiamondVMCallback {
			get {
				if (DrawDiamond_cb_delegate == null)
					DrawDiamond_cb_delegate = new DrawDiamondNativeDelegate (DrawDiamond_cb);
				return DrawDiamond_cb_delegate;
			}
		}

		static void OverrideDrawDiamond (GLib.GType gtype)
		{
			OverrideDrawDiamond (gtype, DrawDiamondVMCallback);
		}

		static void OverrideDrawDiamond (GLib.GType gtype, DrawDiamondNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawDiamond = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawDiamondNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawDiamond_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawDiamond (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawDiamond")]
		protected virtual void OnDrawDiamond (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawDiamond (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawDiamond (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawDiamondNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawDiamond;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawBoxNativeDelegate DrawBox_cb_delegate;
		static DrawBoxNativeDelegate DrawBoxVMCallback {
			get {
				if (DrawBox_cb_delegate == null)
					DrawBox_cb_delegate = new DrawBoxNativeDelegate (DrawBox_cb);
				return DrawBox_cb_delegate;
			}
		}

		static void OverrideDrawBox (GLib.GType gtype)
		{
			OverrideDrawBox (gtype, DrawBoxVMCallback);
		}

		static void OverrideDrawBox (GLib.GType gtype, DrawBoxNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawBox = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawBoxNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawBox_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawBox (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawBox")]
		protected virtual void OnDrawBox (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawBox (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawBox (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawBoxNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawBox;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawFlatBoxNativeDelegate DrawFlatBox_cb_delegate;
		static DrawFlatBoxNativeDelegate DrawFlatBoxVMCallback {
			get {
				if (DrawFlatBox_cb_delegate == null)
					DrawFlatBox_cb_delegate = new DrawFlatBoxNativeDelegate (DrawFlatBox_cb);
				return DrawFlatBox_cb_delegate;
			}
		}

		static void OverrideDrawFlatBox (GLib.GType gtype)
		{
			OverrideDrawFlatBox (gtype, DrawFlatBoxVMCallback);
		}

		static void OverrideDrawFlatBox (GLib.GType gtype, DrawFlatBoxNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawFlatBox = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawFlatBoxNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawFlatBox_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawFlatBox (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawFlatBox")]
		protected virtual void OnDrawFlatBox (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawFlatBox (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawFlatBox (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawFlatBoxNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawFlatBox;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawCheckNativeDelegate DrawCheck_cb_delegate;
		static DrawCheckNativeDelegate DrawCheckVMCallback {
			get {
				if (DrawCheck_cb_delegate == null)
					DrawCheck_cb_delegate = new DrawCheckNativeDelegate (DrawCheck_cb);
				return DrawCheck_cb_delegate;
			}
		}

		static void OverrideDrawCheck (GLib.GType gtype)
		{
			OverrideDrawCheck (gtype, DrawCheckVMCallback);
		}

		static void OverrideDrawCheck (GLib.GType gtype, DrawCheckNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawCheck = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawCheckNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawCheck_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawCheck (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawCheck")]
		protected virtual void OnDrawCheck (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawCheck (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawCheck (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawCheckNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawCheck;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawOptionNativeDelegate DrawOption_cb_delegate;
		static DrawOptionNativeDelegate DrawOptionVMCallback {
			get {
				if (DrawOption_cb_delegate == null)
					DrawOption_cb_delegate = new DrawOptionNativeDelegate (DrawOption_cb);
				return DrawOption_cb_delegate;
			}
		}

		static void OverrideDrawOption (GLib.GType gtype)
		{
			OverrideDrawOption (gtype, DrawOptionVMCallback);
		}

		static void OverrideDrawOption (GLib.GType gtype, DrawOptionNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawOption = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawOptionNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawOption_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawOption (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawOption")]
		protected virtual void OnDrawOption (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawOption (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawOption (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawOptionNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawOption;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawTabNativeDelegate DrawTab_cb_delegate;
		static DrawTabNativeDelegate DrawTabVMCallback {
			get {
				if (DrawTab_cb_delegate == null)
					DrawTab_cb_delegate = new DrawTabNativeDelegate (DrawTab_cb);
				return DrawTab_cb_delegate;
			}
		}

		static void OverrideDrawTab (GLib.GType gtype)
		{
			OverrideDrawTab (gtype, DrawTabVMCallback);
		}

		static void OverrideDrawTab (GLib.GType gtype, DrawTabNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawTab = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawTabNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawTab_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawTab (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawTab")]
		protected virtual void OnDrawTab (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawTab (cr, state_type, shadow_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawTab (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawTabNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawTab;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawShadowGapNativeDelegate DrawShadowGap_cb_delegate;
		static DrawShadowGapNativeDelegate DrawShadowGapVMCallback {
			get {
				if (DrawShadowGap_cb_delegate == null)
					DrawShadowGap_cb_delegate = new DrawShadowGapNativeDelegate (DrawShadowGap_cb);
				return DrawShadowGap_cb_delegate;
			}
		}

		static void OverrideDrawShadowGap (GLib.GType gtype)
		{
			OverrideDrawShadowGap (gtype, DrawShadowGapVMCallback);
		}

		static void OverrideDrawShadowGap (GLib.GType gtype, DrawShadowGapNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawShadowGap = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawShadowGapNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width);

		static void DrawShadowGap_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawShadowGap (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height, (Gtk.PositionType) gap_side, gap_x, gap_width);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawShadowGap")]
		protected virtual void OnDrawShadowGap (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width)
		{
			InternalDrawShadowGap (cr, state_type, shadow_type, widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
		}

		private void InternalDrawShadowGap (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width)
		{
			DrawShadowGapNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawShadowGap;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) gap_side, gap_x, gap_width);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawBoxGapNativeDelegate DrawBoxGap_cb_delegate;
		static DrawBoxGapNativeDelegate DrawBoxGapVMCallback {
			get {
				if (DrawBoxGap_cb_delegate == null)
					DrawBoxGap_cb_delegate = new DrawBoxGapNativeDelegate (DrawBoxGap_cb);
				return DrawBoxGap_cb_delegate;
			}
		}

		static void OverrideDrawBoxGap (GLib.GType gtype)
		{
			OverrideDrawBoxGap (gtype, DrawBoxGapVMCallback);
		}

		static void OverrideDrawBoxGap (GLib.GType gtype, DrawBoxGapNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawBoxGap = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawBoxGapNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width);

		static void DrawBoxGap_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawBoxGap (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height, (Gtk.PositionType) gap_side, gap_x, gap_width);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawBoxGap")]
		protected virtual void OnDrawBoxGap (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width)
		{
			InternalDrawBoxGap (cr, state_type, shadow_type, widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
		}

		private void InternalDrawBoxGap (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width)
		{
			DrawBoxGapNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawBoxGap;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) gap_side, gap_x, gap_width);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawExtensionNativeDelegate DrawExtension_cb_delegate;
		static DrawExtensionNativeDelegate DrawExtensionVMCallback {
			get {
				if (DrawExtension_cb_delegate == null)
					DrawExtension_cb_delegate = new DrawExtensionNativeDelegate (DrawExtension_cb);
				return DrawExtension_cb_delegate;
			}
		}

		static void OverrideDrawExtension (GLib.GType gtype)
		{
			OverrideDrawExtension (gtype, DrawExtensionVMCallback);
		}

		static void OverrideDrawExtension (GLib.GType gtype, DrawExtensionNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawExtension = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawExtensionNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side);

		static void DrawExtension_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawExtension (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height, (Gtk.PositionType) gap_side);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawExtension")]
		protected virtual void OnDrawExtension (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side)
		{
			InternalDrawExtension (cr, state_type, shadow_type, widget, detail, x, y, width, height, gap_side);
		}

		private void InternalDrawExtension (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side)
		{
			DrawExtensionNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawExtension;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) gap_side);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawFocusNativeDelegate DrawFocus_cb_delegate;
		static DrawFocusNativeDelegate DrawFocusVMCallback {
			get {
				if (DrawFocus_cb_delegate == null)
					DrawFocus_cb_delegate = new DrawFocusNativeDelegate (DrawFocus_cb);
				return DrawFocus_cb_delegate;
			}
		}

		static void OverrideDrawFocus (GLib.GType gtype)
		{
			OverrideDrawFocus (gtype, DrawFocusVMCallback);
		}

		static void OverrideDrawFocus (GLib.GType gtype, DrawFocusNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawFocus = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawFocusNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height);

		static void DrawFocus_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawFocus (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawFocus")]
		protected virtual void OnDrawFocus (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			InternalDrawFocus (cr, state_type, widget, detail, x, y, width, height);
		}

		private void InternalDrawFocus (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x, int y, int width, int height)
		{
			DrawFocusNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawFocus;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawSliderNativeDelegate DrawSlider_cb_delegate;
		static DrawSliderNativeDelegate DrawSliderVMCallback {
			get {
				if (DrawSlider_cb_delegate == null)
					DrawSlider_cb_delegate = new DrawSliderNativeDelegate (DrawSlider_cb);
				return DrawSlider_cb_delegate;
			}
		}

		static void OverrideDrawSlider (GLib.GType gtype)
		{
			OverrideDrawSlider (gtype, DrawSliderVMCallback);
		}

		static void OverrideDrawSlider (GLib.GType gtype, DrawSliderNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawSlider = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawSliderNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int orientation);

		static void DrawSlider_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int orientation)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawSlider (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height, (Gtk.Orientation) orientation);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawSlider")]
		protected virtual void OnDrawSlider (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.Orientation orientation)
		{
			InternalDrawSlider (cr, state_type, shadow_type, widget, detail, x, y, width, height, orientation);
		}

		private void InternalDrawSlider (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.Orientation orientation)
		{
			DrawSliderNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawSlider;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) orientation);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawHandleNativeDelegate DrawHandle_cb_delegate;
		static DrawHandleNativeDelegate DrawHandleVMCallback {
			get {
				if (DrawHandle_cb_delegate == null)
					DrawHandle_cb_delegate = new DrawHandleNativeDelegate (DrawHandle_cb);
				return DrawHandle_cb_delegate;
			}
		}

		static void OverrideDrawHandle (GLib.GType gtype)
		{
			OverrideDrawHandle (gtype, DrawHandleVMCallback);
		}

		static void OverrideDrawHandle (GLib.GType gtype, DrawHandleNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawHandle = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawHandleNativeDelegate (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int orientation);

		static void DrawHandle_cb (IntPtr inst, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int orientation)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawHandle (mycr, (Gtk.StateType) state_type, (Gtk.ShadowType) shadow_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, width, height, (Gtk.Orientation) orientation);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawHandle")]
		protected virtual void OnDrawHandle (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.Orientation orientation)
		{
			InternalDrawHandle (cr, state_type, shadow_type, widget, detail, x, y, width, height, orientation);
		}

		private void InternalDrawHandle (Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.Orientation orientation)
		{
			DrawHandleNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawHandle;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) orientation);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawExpanderNativeDelegate DrawExpander_cb_delegate;
		static DrawExpanderNativeDelegate DrawExpanderVMCallback {
			get {
				if (DrawExpander_cb_delegate == null)
					DrawExpander_cb_delegate = new DrawExpanderNativeDelegate (DrawExpander_cb);
				return DrawExpander_cb_delegate;
			}
		}

		static void OverrideDrawExpander (GLib.GType gtype)
		{
			OverrideDrawExpander (gtype, DrawExpanderVMCallback);
		}

		static void OverrideDrawExpander (GLib.GType gtype, DrawExpanderNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawExpander = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawExpanderNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x, int y, int expander_style);

		static void DrawExpander_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int x, int y, int expander_style)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawExpander (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, (Gtk.ExpanderStyle) expander_style);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawExpander")]
		protected virtual void OnDrawExpander (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x, int y, Gtk.ExpanderStyle expander_style)
		{
			InternalDrawExpander (cr, state_type, widget, detail, x, y, expander_style);
		}

		private void InternalDrawExpander (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, int x, int y, Gtk.ExpanderStyle expander_style)
		{
			DrawExpanderNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawExpander;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, (int) expander_style);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawLayoutNativeDelegate DrawLayout_cb_delegate;
		static DrawLayoutNativeDelegate DrawLayoutVMCallback {
			get {
				if (DrawLayout_cb_delegate == null)
					DrawLayout_cb_delegate = new DrawLayoutNativeDelegate (DrawLayout_cb);
				return DrawLayout_cb_delegate;
			}
		}

		static void OverrideDrawLayout (GLib.GType gtype)
		{
			OverrideDrawLayout (gtype, DrawLayoutVMCallback);
		}

		static void OverrideDrawLayout (GLib.GType gtype, DrawLayoutNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawLayout = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawLayoutNativeDelegate (IntPtr inst, IntPtr cr, int state_type, bool use_text, IntPtr widget, IntPtr detail, int x, int y, IntPtr layout);

		static void DrawLayout_cb (IntPtr inst, IntPtr cr, int state_type, bool use_text, IntPtr widget, IntPtr detail, int x, int y, IntPtr layout)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawLayout (mycr, (Gtk.StateType) state_type, use_text, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), x, y, GLib.Object.GetObject(layout) as Pango.Layout);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawLayout")]
		protected virtual void OnDrawLayout (Cairo.Context cr, Gtk.StateType state_type, bool use_text, Gtk.Widget widget, string detail, int x, int y, Pango.Layout layout)
		{
			InternalDrawLayout (cr, state_type, use_text, widget, detail, x, y, layout);
		}

		private void InternalDrawLayout (Cairo.Context cr, Gtk.StateType state_type, bool use_text, Gtk.Widget widget, string detail, int x, int y, Pango.Layout layout)
		{
			DrawLayoutNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawLayout;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, use_text, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, layout == null ? IntPtr.Zero : layout.Handle);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawResizeGripNativeDelegate DrawResizeGrip_cb_delegate;
		static DrawResizeGripNativeDelegate DrawResizeGripVMCallback {
			get {
				if (DrawResizeGrip_cb_delegate == null)
					DrawResizeGrip_cb_delegate = new DrawResizeGripNativeDelegate (DrawResizeGrip_cb);
				return DrawResizeGrip_cb_delegate;
			}
		}

		static void OverrideDrawResizeGrip (GLib.GType gtype)
		{
			OverrideDrawResizeGrip (gtype, DrawResizeGripVMCallback);
		}

		static void OverrideDrawResizeGrip (GLib.GType gtype, DrawResizeGripNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawResizeGrip = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawResizeGripNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int edge, int x, int y, int width, int height);

		static void DrawResizeGrip_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, int edge, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawResizeGrip (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), (Gdk.WindowEdge) edge, x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawResizeGrip")]
		protected virtual void OnDrawResizeGrip (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, Gdk.WindowEdge edge, int x, int y, int width, int height)
		{
			InternalDrawResizeGrip (cr, state_type, widget, detail, edge, x, y, width, height);
		}

		private void InternalDrawResizeGrip (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, Gdk.WindowEdge edge, int x, int y, int width, int height)
		{
			DrawResizeGripNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawResizeGrip;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, (int) edge, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		static DrawSpinnerNativeDelegate DrawSpinner_cb_delegate;
		static DrawSpinnerNativeDelegate DrawSpinnerVMCallback {
			get {
				if (DrawSpinner_cb_delegate == null)
					DrawSpinner_cb_delegate = new DrawSpinnerNativeDelegate (DrawSpinner_cb);
				return DrawSpinner_cb_delegate;
			}
		}

		static void OverrideDrawSpinner (GLib.GType gtype)
		{
			OverrideDrawSpinner (gtype, DrawSpinnerVMCallback);
		}

		static void OverrideDrawSpinner (GLib.GType gtype, DrawSpinnerNativeDelegate callback)
		{
			GtkStyleClass class_iface = GetClassStruct (gtype, false);
			class_iface.DrawSpinner = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DrawSpinnerNativeDelegate (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, uint step, int x, int y, int width, int height);

		static void DrawSpinner_cb (IntPtr inst, IntPtr cr, int state_type, IntPtr widget, IntPtr detail, uint step, int x, int y, int width, int height)
		{
			Cairo.Context mycr = null;

			try {
				Style __obj = GLib.Object.GetObject (inst, false) as Style;
				mycr = new Cairo.Context (cr, false);
				__obj.OnDrawSpinner (mycr, (Gtk.StateType) state_type, GLib.Object.GetObject(widget) as Gtk.Widget, GLib.Marshaller.Utf8PtrToString (detail), step, x, y, width, height);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			} finally {
				var disposable_cr = mycr as IDisposable;
				if (disposable_cr != null)
					disposable_cr.Dispose ();
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.Style), ConnectionMethod="OverrideDrawSpinner")]
		protected virtual void OnDrawSpinner (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, uint step, int x, int y, int width, int height)
		{
			InternalDrawSpinner (cr, state_type, widget, detail, step, x, y, width, height);
		}

		private void InternalDrawSpinner (Cairo.Context cr, Gtk.StateType state_type, Gtk.Widget widget, string detail, uint step, int x, int y, int width, int height)
		{
			DrawSpinnerNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DrawSpinner;
			if (unmanaged == null) return;

			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			unmanaged (this.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, step, x, y, width, height);
			GLib.Marshaller.Free (native_detail);
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GtkStyleClass {
			public RealizeNativeDelegate Realize;
			public UnrealizeNativeDelegate Unrealize;
			public CopyNativeDelegate Copy;
			public CloneNativeDelegate Clone;
			public InitFromRcNativeDelegate InitFromRc;
			public SetBackgroundNativeDelegate SetBackground;
			public RenderIconNativeDelegate RenderIcon;
			public DrawHlineNativeDelegate DrawHline;
			public DrawVlineNativeDelegate DrawVline;
			public DrawShadowNativeDelegate DrawShadow;
			public DrawArrowNativeDelegate DrawArrow;
			public DrawDiamondNativeDelegate DrawDiamond;
			public DrawBoxNativeDelegate DrawBox;
			public DrawFlatBoxNativeDelegate DrawFlatBox;
			public DrawCheckNativeDelegate DrawCheck;
			public DrawOptionNativeDelegate DrawOption;
			public DrawTabNativeDelegate DrawTab;
			public DrawShadowGapNativeDelegate DrawShadowGap;
			public DrawBoxGapNativeDelegate DrawBoxGap;
			public DrawExtensionNativeDelegate DrawExtension;
			public DrawFocusNativeDelegate DrawFocus;
			public DrawSliderNativeDelegate DrawSlider;
			public DrawHandleNativeDelegate DrawHandle;
			public DrawExpanderNativeDelegate DrawExpander;
			public DrawLayoutNativeDelegate DrawLayout;
			public DrawResizeGripNativeDelegate DrawResizeGrip;
			public DrawSpinnerNativeDelegate DrawSpinner;
			IntPtr GtkReserved1;
			IntPtr GtkReserved2;
			IntPtr GtkReserved3;
			IntPtr GtkReserved4;
			IntPtr GtkReserved5;
			IntPtr GtkReserved6;
			IntPtr GtkReserved7;
			IntPtr GtkReserved8;
			IntPtr GtkReserved9;
			IntPtr GtkReserved10;
			IntPtr GtkReserved11;
		}

		static uint class_offset = ((GLib.GType) typeof (GLib.Object)).GetClassSize ();
		static Dictionary<GLib.GType, GtkStyleClass> class_structs;

		static GtkStyleClass GetClassStruct (GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Dictionary<GLib.GType, GtkStyleClass> ();

			if (use_cache && class_structs.ContainsKey (gtype))
				return class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GtkStyleClass class_struct = (GtkStyleClass) Marshal.PtrToStructure (class_ptr, typeof (GtkStyleClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (GLib.GType gtype, GtkStyleClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_style_attach(IntPtr raw, IntPtr window);

		[Obsolete]
		public Gtk.Style Attach(Gdk.Window window) {
			IntPtr raw_ret = gtk_style_attach(Handle, window == null ? IntPtr.Zero : window.Handle);
			Gtk.Style ret = GLib.Object.GetObject(raw_ret) as Gtk.Style;
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_style_copy(IntPtr raw);

		[Obsolete]
		public Gtk.Style Copy() {
			IntPtr raw_ret = gtk_style_copy(Handle);
			Gtk.Style ret = GLib.Object.GetObject(raw_ret, true) as Gtk.Style;
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_style_detach(IntPtr raw);

		[Obsolete]
		public void Detach() {
			gtk_style_detach(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_style_get_type();

		[Obsolete]
		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gtk_style_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_style_set_background(IntPtr raw, IntPtr window, int state_type);

		[Obsolete]
		public void SetBackground(Gdk.Window window, Gtk.StateType state_type) {
			gtk_style_set_background(Handle, window == null ? IntPtr.Zero : window.Handle, (int) state_type);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paint_box_gap(IntPtr style, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width);

		[Obsolete]
		public static void PaintBoxGap(Gtk.Style style, Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width) {
			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			gtk_paint_box_gap(style == null ? IntPtr.Zero : style.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) gap_side, gap_x, gap_width);
			GLib.Marshaller.Free (native_detail);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_paint_shadow_gap(IntPtr style, IntPtr cr, int state_type, int shadow_type, IntPtr widget, IntPtr detail, int x, int y, int width, int height, int gap_side, int gap_x, int gap_width);

		[Obsolete]
		public static void PaintShadowGap(Gtk.Style style, Cairo.Context cr, Gtk.StateType state_type, Gtk.ShadowType shadow_type, Gtk.Widget widget, string detail, int x, int y, int width, int height, Gtk.PositionType gap_side, int gap_x, int gap_width) {
			IntPtr native_detail = GLib.Marshaller.StringToPtrGStrdup (detail);
			gtk_paint_shadow_gap(style == null ? IntPtr.Zero : style.Handle, cr == null ? IntPtr.Zero : cr.Handle, (int) state_type, (int) shadow_type, widget == null ? IntPtr.Zero : widget.Handle, native_detail, x, y, width, height, (int) gap_side, gap_x, gap_width);
			GLib.Marshaller.Free (native_detail);
		}

#endregion
	}
}
